global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 5.0
      always_send_full_costmap: True
      width: 100
      height: 100
      resolution: 0.1
      global_frame: map
      robot_base_frame: base_link
      rolling_window: True # move with the robot
      track_unknown_space: False # mark unknown space as free
      plugins: ["stvl", "inflation_layer"]
      stvl:
        # Why STVL?
        # - Standard voxel layer only clears obstacles when other obstacles are detected behind them.
        # - STVL on the other hand clears obstacles when they are not detected anymore in the frustum.
        # - Static layer does not have its own memory like voxel layers so it is not suitable for mapping.
        plugin: "spatio_temporal_voxel_layer/SpatioTemporalVoxelLayer"
        enabled: true
        voxel_decay: 10.0               # seconds if linear, e^n if exponential
        decay_model: -1                 # 0=linear, 1=exponential, -1=persistent
        voxel_size: 0.1                 # meters
        track_unknown_space: true       # default space is unknown
        mark_threshold: 0               # voxel height
        update_footprint_enabled: true  # default off
        combination_method: 1           # 1=max, 0=override
        origin_z: 0.0                   # meters
        publish_voxel_map: true         # default off
        transform_tolerance: 0.2        # seconds
        mapping_mode: false             # default off, saves map not for navigation
        map_save_duration: 60.0         # default 60s, how often to autosave
        # observation_sources: d455_front d455_back d455_left d455_right
        # d455_front:
        #   data_type: PointCloud2
        #   topic: /d455_front/obstacles
        #   marking: true
        #   clearing: true

        #   # Marking params:
        #   obstacle_range: 10.0            # meters
        #   min_obstacle_height: -1000.0    # default 0, meters
        #   max_obstacle_height: 1000.0     # default 3, meters
        #   expected_update_rate: 0.0       # default 0, if not updating at this rate at least, remove from buffer
        #   observation_persistence: 0.0    # default 0, use all measurements taken during now-value, 0=latest # Q: Does this average the last X seconds of observations before testing for occupancy?
        #   inf_is_valid: false             # default false, for laser scans
        #   clear_after_reading: true       # default false, clear the buffer after the layer gets readings from it
        #   filter: "voxel"                 # default passthrough, apply "voxel", "passthrough", or no filter to sensor data, recommended to have at one filter on
        #   voxel_min_points: 0             # default 0, minimum points per voxel for voxel filter
            
        #   # Clearing params:
        #   min_z: 0.0                      # default 0, meters
        #   max_z: 5.0                      # default 10, meters
        #   vertical_fov_angle: 1.025       # default 0.7, radians
        #   horizontal_fov_angle: 1.571     # default 1.04, radians
        #   decay_acceleration: 100.0        # default 0, 1/s^2. If laser scanner MUST be 0
        #   model_type: 0                   # default 0 (depth camera). Use 1 for 3D Lidar

        # Multi-camera setup using Jinja2 templating:
        observation_sources: {{ rgbd_ids | join(' ') }}
{% for camera_id in rgbd_ids %}
        {{ camera_id }}:
          data_type: PointCloud2
          topic: /{{ camera_id }}/obstacles # Substituted in launch file.
          marking: true
          clearing: true

          # Marking params:
          obstacle_range: 10.0            # meters
          min_obstacle_height: -1000.0    # default 0, meters
          max_obstacle_height: 1000.0     # default 3, meters
          clear_after_reading: true       # default false, clear the buffer after the layer gets readings from it
          filter: "voxel"                 # default passthrough, apply "voxel", "passthrough", or no filter to sensor data, recommended to have at one filter on
            
          # Clearing params:
          max_z: 5.0                      # default 10, meters
          vertical_fov_angle: 1.025       # default 0.7, radians
          horizontal_fov_angle: 1.571     # default 1.04, radians
          decay_acceleration: 10.0        # default 0, 1/s^2. If laser scanner MUST be 0
{% endfor %}

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 0.1
        inflation_radius: 0.7

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 5.0
      always_send_full_costmap: True
      width: 10
      height: 10
      resolution: 0.1
      global_frame: odom
      robot_base_frame: base_link
      rolling_window: True # move with robot
      track_unknown_space: False # mark unknown space as free
      plugins: ["inflation_layer"]
      # voxel_layer:
      #   plugin: "nav2_costmap_2d::VoxelLayer"
      #   enabled: True
      #   footprint_clearing_enabled: False
      #   max_obstacle_height: 1000000.0
      #   unknown_threshold: 1000000
      #   mark_threshold: 0
      #   combination_method: 0 # =overwrite; 1=max; 2=max without unknown overwrite
      #   observation_sources: obstacle_cloud
      #   obstacle_cloud:
      #     topic: /rtabmap/local_grid_obstacle
      #     observation_persistence: 0.0
      #     expected_update_rate: 0.0
      #     data_type: "PointCloud2"
      #     min_obstacle_height: -1000000.0
      #     max_obstacle_height: 1000000.0
      #     inf_is_valid: False
      #     marking: True
      #     clearing: False
      #     obstacle_max_range: 1000000.0
      #     obstacle_min_range: 0.0
      #     raytrace_max_range: 0.0
      #     raytrace_min_range: 0.0
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 0.01
        inflation_radius: 0.7

behavior_server:
  ros__parameters:
    # Enabled plugins are used by the behavior trees.
    behavior_plugins: ["spin", "backup"]
    spin:
      plugin: "nav2_behaviors/Spin"
    backup:
      plugin: "nav2_behaviors/BackUp"

bt_navigator:
  ros__parameters:
    default_nav_to_pose_bt_xml: $(find-pkg-share kalman_nav2)/behavior_trees/nav_to_pose.xml
    default_nav_through_poses_bt_xml: $(find-pkg-share kalman_nav2)/behavior_trees/nav_through_poses.xml
    global_frame: map
    robot_base_frame: base_link
    odom_topic: /odometry/filtered
    bt_loop_duration: 10
    default_server_timeout: 20
    action_server_result_timeout: 900.0
    navigators: ["navigate_to_pose", "navigate_through_poses"]
    navigate_to_pose:
      plugin: "nav2_bt_navigator/NavigateToPoseNavigator"
    navigate_through_poses:
      plugin: "nav2_bt_navigator/NavigateThroughPosesNavigator"
    plugin_lib_names:
      - nav2_compute_path_to_pose_action_bt_node
      - nav2_compute_path_through_poses_action_bt_node
      - nav2_smooth_path_action_bt_node
      - nav2_follow_path_action_bt_node
      - nav2_spin_action_bt_node
      - nav2_wait_action_bt_node
      - nav2_assisted_teleop_action_bt_node
      - nav2_back_up_action_bt_node
      - nav2_drive_on_heading_bt_node
      - nav2_clear_costmap_service_bt_node
      - nav2_is_stuck_condition_bt_node
      - nav2_goal_reached_condition_bt_node
      - nav2_goal_updated_condition_bt_node
      - nav2_globally_updated_goal_condition_bt_node
      - nav2_is_path_valid_condition_bt_node
      - nav2_initial_pose_received_condition_bt_node
      - nav2_reinitialize_global_localization_service_bt_node
      - nav2_rate_controller_bt_node
      - nav2_distance_controller_bt_node
      - nav2_speed_controller_bt_node
      - nav2_truncate_path_action_bt_node
      - nav2_truncate_path_local_action_bt_node
      - nav2_goal_updater_node_bt_node
      - nav2_recovery_node_bt_node
      - nav2_pipeline_sequence_bt_node
      - nav2_round_robin_node_bt_node
      - nav2_transform_available_condition_bt_node
      - nav2_time_expired_condition_bt_node
      - nav2_path_expiring_timer_condition
      - nav2_distance_traveled_condition_bt_node
      - nav2_single_trigger_bt_node
      - nav2_goal_updated_controller_bt_node
      - nav2_is_battery_low_condition_bt_node
      - nav2_navigate_through_poses_action_bt_node
      - nav2_navigate_to_pose_action_bt_node
      - nav2_remove_passed_goals_action_bt_node
      - nav2_planner_selector_bt_node
      - nav2_controller_selector_bt_node
      - nav2_goal_checker_selector_bt_node
      - nav2_controller_cancel_bt_node
      - nav2_path_longer_on_approach_bt_node
      - nav2_wait_cancel_bt_node
      - nav2_spin_cancel_bt_node
      - nav2_back_up_cancel_bt_node
      - nav2_assisted_teleop_cancel_bt_node
      - nav2_drive_on_heading_cancel_bt_node
      - nav2_is_battery_charging_condition_bt_node
    error_code_names:
      - compute_path_error_code
      - follow_path_error_code

planner_server:
  ros__parameters:
    expected_planner_frequency: 10.0 # planning Hz
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      tolerance: 5.0 # Plan path to a point max meters from goal; Navfn will loop (2 * tolerance / grid resolution)^2 = 10000 times
      use_astar: True # Use A* or Dijkstra's?
      allow_unknown: True # Plan in unknown space?
    # GridBased:
    #   plugin: "nav2_smac_planner/SmacPlannerHybrid"
    #   downsample_costmap: false           # whether or not to downsample the map
    #   downsampling_factor: 1              # multiplier for the resolution of the costmap layer (e.g. 2 on a 5cm costmap would be 10cm)
    #   tolerance: 0.25                     # dist-to-goal heuristic cost (distance) for valid tolerance endpoints if exact goal cannot be found.
    #   allow_unknown: true                 # allow traveling in unknown space
    #   max_iterations: 1000000             # maximum total iterations to search for before failing (in case unreachable), set to -1 to disable
    #   max_on_approach_iterations: 1000    # Maximum number of iterations after within tolerances to continue to try to find exact solution
    #   max_planning_time: 5.0              # max time in s for planner to plan, smooth
    #   motion_model_for_search: "DUBIN"    # Hybrid-A* Dubin, Redds-Shepp
    #   angle_quantization_bins: 72         # Number of angle bins for search
    #   analytic_expansion_ratio: 3.5       # The ratio to attempt analytic expansions during search for final approach.
    #   analytic_expansion_max_length: 3.0  # For Hybrid/Lattice nodes: The maximum length of the analytic expansion to be considered valid to prevent unsafe shortcutting
    #   minimum_turning_radius: 0.40        # minimum turning radius in m of path / vehicle
    #   reverse_penalty: 2.0                # Penalty to apply if motion is reversing, must be => 1
    #   change_penalty: 0.0                 # Penalty to apply if motion is changing directions (L to R), must be >= 0
    #   non_straight_penalty: 1.2           # Penalty to apply if motion is non-straight, must be => 1
    #   cost_penalty: 100.0                   # Penalty to apply to higher cost areas when adding into the obstacle map dynamic programming distance expansion heuristic. This drives the robot more towards the center of passages. A value between 1.3 - 3.5 is reasonable.
    #   retrospective_penalty: 0.015
    #   lookup_table_size: 20.0             # Size of the dubin/reeds-sheep distance window to cache, in meters.
    #   cache_obstacle_heuristic: false     # Cache the obstacle map dynamic programming distance expansion heuristic between subsiquent replannings of the same goal location. Dramatically speeds up replanning performance (40x) if costmap is largely static.
    #   debug_visualizations: false         # For Hybrid nodes: Whether to publish expansions on the /expansions topic as an array of poses (the orientation has no meaning) and the path's footprints on the /planned_footprints topic. WARNING: heavy to compute and to display, for debug only as it degrades the performance.
    #   use_quadratic_cost_penalty: False
    #   downsample_obstacle_heuristic: True
    #   allow_primitive_interpolation: False
      # smooth_path: True                   # If true, does a simple and quick smoothing post-processing to the path

      # smoother:
      #   max_iterations: 1000
      #   w_smooth: 0.3
      #   w_data: 0.2
      #   tolerance: 1.0e-10
      #   do_refinement: true
      #   refinement_num: 2
    # GridBased:
    #   plugin: "nav2_smac_planner/SmacPlanner2D"
    #   tolerance: 1000000.0                  # tolerance for planning if unable to reach exact pose, in meters
    #   downsample_costmap: false             # whether or not to downsample the map
    #   downsampling_factor: 1                # multiplier for the resolution of the costmap layer (e.g. 2 on a 5cm costmap would be 10cm)
    #   allow_unknown: true                   # allow traveling in unknown space
    #   max_iterations: -1                    # maximum total iterations to search for before failing (in case unreachable), set to -1 to disable
    #   max_on_approach_iterations: 1000      # maximum number of iterations to attempt to reach goal once in tolerance
    #   max_planning_time: 5.0                # max time in s for planner to plan, smooth
    #   cost_travel_multiplier: 2.0           # Cost multiplier to apply to search to steer away from high cost areas. Larger values will place in the center of aisles more exactly (if non-`FREE` cost potential field exists) but take slightly longer to compute. To optimize for speed, a value of 1.0 is reasonable. A reasonable tradeoff value is 2.0. A value of 0.0 effective disables steering away from obstacles and acts like a naive binary search A*.
    #   use_final_approach_orientation: false # Whether to set the final path pose at the goal's orientation to the requested orientation (false) or in line with the approach angle so the robot doesn't rotate to heading (true)
    #   smoother:
    #     max_iterations: 1000
    #     w_smooth: 0.3
    #     w_data: 0.2
    #     tolerance: 1e-10

controller_server:
  ros__parameters:
    controller_frequency: 10.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.001
    min_theta_velocity_threshold: 0.001
    failure_tolerance: 0.0 # disable failure detection
    
    progress_checker_plugin: "progress_checker"
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 1.0 # robot must have moved 1 m
      movement_time_allowance: 30.0 # in the last 10 seconds
    
    goal_checker_plugins: ["simple_goal_checker"]
    simple_goal_checker:
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 1.0 # meters
      yaw_goal_tolerance: 1000000.0 # radians
      stateful: True # check XY after rotating
    
    controller_plugins: ["FollowPath"]
    FollowPath:
      plugin: "service_based_nav2_controller::ServiceBasedNav2Controller"
      compute_velocity_commands_service: "/path_follower/compute_velocity_commands"

velocity_smoother:
  ros__parameters:
    # Frequency (Hz) to use the last received velocity command to smooth by velocity, acceleration, and deadband constraints. If set approximately to the rate of your local trajectory planner, it should smooth by acceleration constraints velocity commands. If set much higher, it will interpolate and provide a smooth set of commands to the hardware controller.
    smoothing_frequency: 10.0
    # Whether or not to adjust other components of velocity proportionally to a component’s required changes due to acceleration limits. This will try to adjust all components to follow the same direction, but still enforces acceleration limits to guarantee compliance, even if it means deviating off commanded trajectory slightly.
    scale_velocities: false
    # Type of feedback to use for the current state of the robot’s velocity. In OPEN_LOOP, it will use the last commanded velocity as the next iteration’s current velocity. When acceleration limits are set appropriately, this is a good assumption. In CLOSED_LOOP, it will use the odometry from the odom topic to estimate the robot’s current speed. In closed loop mode, it is important that the odometry is high rate and low latency, relative to the smoothing frequency.
    feedback: "OPEN_LOOP"
    # Maximum velocities (m/s) in [x, y, theta] axes.
    max_velocity: [2.0, 2.0, 2.0]
    # Minimum velocities (m/s) in [x, y, theta] axes. This is signed and thus must be negative to reverse. Note: rotational velocities negative direction is a right-hand turn, so this should always be negative regardless of reversing preference.
    min_velocity: [-2.0, -2.0, -2.0]
    # Minimum velocities (m/s) to send to the robot hardware controllers, to prevent small commands from damaging hardware controllers if that speed cannot be achieved due to stall torque.
    deadband_velocity: [0.0, 0.0, 0.0]
    # Timeout (s) after which the velocity smoother will send a zero-ed out Twist command and stop publishing.
    velocity_timeout: 1.0
    # Maximum acceleration to apply to each axis [x, y, theta].
    max_accel: [1.0, 1.0, 1.0]
    # Minimum acceleration to apply to each axis [x, y, theta]. This is signed and thus these should generally all be negative.
    max_decel: [-1.0, -1.0, -1.0]
    # Topic to find robot odometry, if in CLOSED_LOOP operational mode.
    # odom_topic: "odom"
    # Time (s) to buffer odometry commands to estimate the robot speed, if in CLOSED_LOOP operational mode.
    # odom_duration: 0.1
